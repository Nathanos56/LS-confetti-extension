/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./content_scripts/confetti.js":
/*!*************************************!*\
  !*** ./content_scripts/confetti.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var canvas_confetti__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! canvas-confetti */ \"./node_modules/canvas-confetti/dist/confetti.module.mjs\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// toDo:\n// add css animations in the popup\n// change default color of the color pickers in popup.js\n// create steelwool effect\n\n\nfunction initialConfetti(profileSettings) {\n  var MyparticleCount = profileSettings['particleSlider'] || 150;\n  var angle = profileSettings['angleSlider'] || 90;\n  var spread = profileSettings['spreadSlider'] || 270;\n  var velocity = profileSettings['velocitySlider'] || 45;\n  var decay = profileSettings['decaySlider'] || 0.9;\n  var gravity = profileSettings['gravitySlider'] || 1;\n  var drift = profileSettings['driftSlider'] || 0;\n  var ticks = profileSettings['tickSlider'] || 200;\n  var size = profileSettings['particleSizeSlider'] || 1;\n  var burstNum = profileSettings['burstSlider'] || 5;\n  var color1 = profileSettings['colorSelector1'] || '#f00';\n  var color2 = profileSettings['colorSelector2'] || '#00f';\n  var color3 = profileSettings['colorSelector3'] || '#0f0';\n\n  // Default values are commented\n  var testConfettiSettings = {\n    particleCount: MyparticleCount,\n    // 50\n    angle: angle,\n    // 90\n    spread: spread,\n    // 45\n    startVelocity: velocity,\n    // 45\n    decay: decay,\n    // .9\n    gravity: gravity,\n    // 1\n    drift: drift,\n    // 0\n    flat: false,\n    // false\n    ticks: ticks,\n    // 200   how many times the confetti will move\n    //origin: object,\n    scalar: size,\n    // 1      size of particles\n    colors: [color1, color2, color3] // Adjust the confetti colors\n  };\n  (0,canvas_confetti__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(testConfettiSettings);\n  randomConfetti(burstNum, color1, color2, color3);\n}\nfunction randomConfetti(burstNum, color1, color2, color3) {\n  return new Promise(function (resolve) {\n    var interval = 200;\n    var numExplosions = burstNum;\n    var count = 0;\n    var intervalId = setInterval(function () {\n      (0,canvas_confetti__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        particleCount: 50,\n        spread: 360,\n        startVelocity: 30,\n        origin: {\n          x: Math.random(),\n          y: Math.random() - 0.2\n        },\n        scalar: .8,\n        colors: [color1, color2, color3]\n      });\n      ++count;\n      if (count >= numExplosions) {\n        clearInterval(intervalId);\n        resolve();\n      }\n    }, interval);\n  });\n}\nfunction steelWool(profileSettings) {}\nfunction fireworks(profileSettings) {\n  var inputTime = profileSettings['timeSlider'] || 5;\n  var MyparticleCount = profileSettings['particleSlider'] || 150;\n  var duration = inputTime * 1000;\n  var animationEnd = Date.now() + duration;\n  var settings = {\n    velocity: profileSettings['velocitySlider'] || 30,\n    spread: profileSettings['spreadSlider'] || 360,\n    ticks: profileSettings['tickSlider'] || 60,\n    zIndex: 0,\n    colors: [profileSettings['colorSelector1'] || '#f00', profileSettings['colorSelector2'] || '#00f', profileSettings['colorSelector3'] || '#0f0'],\n    particleCount: MyparticleCount * (timeLeft / duration) //this fades out the fireworks\n  };\n  function randomInRange(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n  var interval = setInterval(function () {\n    var timeLeft = animationEnd - Date.now();\n    if (timeLeft <= 0) {\n      return clearInterval(interval);\n    }\n\n    // since particles fall down, start a bit higher than random\n    (0,canvas_confetti__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_objectSpread(_objectSpread({}, settings), {}, {\n      origin: {\n        x: randomInRange(0.1, 0.3),\n        y: Math.random() - 0.2\n      }\n    }));\n    (0,canvas_confetti__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_objectSpread(_objectSpread({}, settings), {}, {\n      origin: {\n        x: randomInRange(0.7, 0.9),\n        y: Math.random() - 0.2\n      }\n    }));\n  }, 250); //250ms between launches\n}\nfunction snow(profileSettings) {\n  var inputTime = profileSettings['timeSlider'] || 5;\n  var duration = inputTime * 1000;\n  var animationEnd = Date.now() + duration;\n  var skew = 1;\n  function randomInRange(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n  (function frame() {\n    var timeLeft = animationEnd - Date.now();\n    var ticks = Math.max(profileSettings['tickSlider'] || 200, 500 * (timeLeft / duration));\n    skew = Math.max(0.8, skew - 0.001);\n    (0,canvas_confetti__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      particleCount: 1,\n      startVelocity: 0,\n      ticks: ticks,\n      origin: {\n        x: Math.random(),\n        y: Math.random() * skew - 0.2 // since particles fall down, skew start toward the top\n      },\n      colors: [profileSettings['colorSelector1'] || '#ffffff', profileSettings['colorSelector2'] || '#ffffff', profileSettings['colorSelector3'] || '#ffffff'],\n      shapes: ['circle'],\n      gravity: randomInRange(0.4, 0.6),\n      scalar: randomInRange(0.4, 1),\n      drift: randomInRange(-0.4, 0.4)\n    });\n    if (timeLeft > 0) {\n      requestAnimationFrame(frame);\n    }\n  })();\n}\n\n// splitting this into its own function lets the user test settings without refreshing the page\nfunction getSettings() {\n  return new Promise(function (resolve, reject) {\n    chrome.storage.sync.get('selectedProfile', function (data) {\n      var selectedProfile = data.selectedProfile;\n\n      // gets the profiles object\n      chrome.storage.sync.get('profiles', function (data) {\n        var profiles = data.profiles || {};\n        resolve(profiles[selectedProfile] || {}); //returns profileSettings\n      });\n    });\n  });\n}\nwindow.onload = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n  var LSSubmit, LSCheckOff, profileSettings, checkOffEnabled, handleClick, attachClickListener, observer;\n  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        // console.log('%cinside dom event listener', 'color: green; font-weight: bold;');\n        LSSubmit = '[data-v-625658].text-white.bg-primary-dark.hover\\\\:bg-primary-alt.p-px.font-metro.focus\\\\:outline-none.transition-colors.duration-150';\n        LSCheckOff = '[data-v--363100].float-right.ml-2.w-28.text-white.bg-primary-dark.hover\\\\:bg-primary-alt.p-px.font-metro.focus\\\\:outline-none.transition-colors.duration-150';\n        _context2.prev = 2;\n        _context2.next = 5;\n        return getSettings();\n      case 5:\n        profileSettings = _context2.sent;\n        _context2.next = 11;\n        break;\n      case 8:\n        _context2.prev = 8;\n        _context2.t0 = _context2[\"catch\"](2);\n        console.error('An error occurred with getSettings:', _context2.t0);\n      case 11:\n        checkOffEnabled = profileSettings[\"checkOffSwitch\"] || false;\n        attachClickListener(); //initial attach\n        handleClick = /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {\n            var confettiType;\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return getSettings();\n                case 3:\n                  profileSettings = _context.sent;\n                  _context.next = 9;\n                  break;\n                case 6:\n                  _context.prev = 6;\n                  _context.t0 = _context[\"catch\"](0);\n                  console.error('An error occurred with getSettings:', _context.t0);\n                case 9:\n                  checkOffEnabled = profileSettings[\"checkOffSwitch\"] || false;\n                  confettiType = profileSettings[\"selectedProfile\"] || \"confetti\";\n                  _context.t1 = confettiType;\n                  _context.next = _context.t1 === \"confetti\" ? 14 : _context.t1 === \"steelWool\" ? 16 : _context.t1 === \"fireworks\" ? 18 : _context.t1 === \"snow\" ? 20 : 22;\n                  break;\n                case 14:\n                  initialConfetti(profileSettings);\n                  return _context.abrupt(\"break\", 22);\n                case 16:\n                  steelWool(profileSettings);\n                  return _context.abrupt(\"break\", 22);\n                case 18:\n                  fireworks(profileSettings);\n                  return _context.abrupt(\"break\", 22);\n                case 20:\n                  snow(profileSettings);\n                  return _context.abrupt(\"break\", 22);\n                case 22:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee, null, [[0, 6]]);\n          }));\n          return function handleClick(_x) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n        attachClickListener = function attachClickListener() {\n          var submitButtons = Array.from(document.querySelectorAll(LSSubmit));\n          if (checkOffEnabled) {\n            var buttons = document.querySelectorAll(LSCheckOff);\n            var checkOffButtons = Array.from(buttons).filter(function (button) {\n              var childDivs = button.querySelectorAll('div');\n              return Array.from(childDivs).some(function (div) {\n                return div.textContent.includes('Check Off');\n              });\n            });\n            submitButtons = submitButtons.concat(checkOffButtons);\n          }\n          submitButtons.forEach(function (submitButton) {\n            if (!submitButton.hasClickListener) {\n              submitButton.addEventListener('click', handleClick);\n              submitButton.hasClickListener = true;\n            }\n          });\n        }; // when the dom changes\n        observer = new MutationObserver(function (mutationsList, observer) {\n          var _iterator = _createForOfIteratorHelper(mutationsList),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var mutation = _step.value;\n              if (mutation.type === 'childList' || mutation.type === 'attributes' || mutation.type === 'characterData') {\n                attachClickListener();\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n        observer.observe(document.body, {\n          childList: true,\n          attributes: true,\n          characterData: true,\n          subtree: true\n        });\n\n        // console.log('%cjs file loaded', 'color: green; font-weight: bold;');\n      case 17:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, _callee2, null, [[2, 8]]);\n}));\n\n// this was a test for submit buttons on all websites:\n// const submitButtons = document.querySelectorAll('input[type=\"submit\"], button[type=\"submit\"], button[data-v-625658]');\n// event.preventDefault();\n// event.removeEventListener('click', handleClick);\n// event.target.click(); // perform default button action\n// event.addEventListener('click', handleClick);\n\n//# sourceURL=webpack:///./content_scripts/confetti.js?");

/***/ }),

/***/ "./node_modules/canvas-confetti/dist/confetti.module.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/canvas-confetti/dist/confetti.module.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// canvas-confetti v1.9.2 built on 2023-11-25T06:01:06.267Z\r\nvar module = {};\r\n\r\n// source content\r\n/* globals Map */\r\n\r\n(function main(global, module, isWorker, workerSize) {\r\n  var canUseWorker = !!(\r\n    global.Worker &&\r\n    global.Blob &&\r\n    global.Promise &&\r\n    global.OffscreenCanvas &&\r\n    global.OffscreenCanvasRenderingContext2D &&\r\n    global.HTMLCanvasElement &&\r\n    global.HTMLCanvasElement.prototype.transferControlToOffscreen &&\r\n    global.URL &&\r\n    global.URL.createObjectURL);\r\n\r\n  var canUsePaths = typeof Path2D === 'function' && typeof DOMMatrix === 'function';\r\n  var canDrawBitmap = (function () {\r\n    // this mostly supports ssr\r\n    if (!global.OffscreenCanvas) {\r\n      return false;\r\n    }\r\n\r\n    var canvas = new OffscreenCanvas(1, 1);\r\n    var ctx = canvas.getContext('2d');\r\n    ctx.fillRect(0, 0, 1, 1);\r\n    var bitmap = canvas.transferToImageBitmap();\r\n\r\n    try {\r\n      ctx.createPattern(bitmap, 'no-repeat');\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  })();\r\n\r\n  function noop() {}\r\n\r\n  // create a promise if it exists, otherwise, just\r\n  // call the function directly\r\n  function promise(func) {\r\n    var ModulePromise = module.exports.Promise;\r\n    var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;\r\n\r\n    if (typeof Prom === 'function') {\r\n      return new Prom(func);\r\n    }\r\n\r\n    func(noop, noop);\r\n\r\n    return null;\r\n  }\r\n\r\n  var bitmapMapper = (function (skipTransform, map) {\r\n    // see https://github.com/catdad/canvas-confetti/issues/209\r\n    // creating canvases is actually pretty expensive, so we should create a\r\n    // 1:1 map for bitmap:canvas, so that we can animate the confetti in\r\n    // a performant manner, but also not store them forever so that we don't\r\n    // have a memory leak\r\n    return {\r\n      transform: function(bitmap) {\r\n        if (skipTransform) {\r\n          return bitmap;\r\n        }\r\n\r\n        if (map.has(bitmap)) {\r\n          return map.get(bitmap);\r\n        }\r\n\r\n        var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\r\n        var ctx = canvas.getContext('2d');\r\n        ctx.drawImage(bitmap, 0, 0);\r\n\r\n        map.set(bitmap, canvas);\r\n\r\n        return canvas;\r\n      },\r\n      clear: function () {\r\n        map.clear();\r\n      }\r\n    };\r\n  })(canDrawBitmap, new Map());\r\n\r\n  var raf = (function () {\r\n    var TIME = Math.floor(1000 / 60);\r\n    var frame, cancel;\r\n    var frames = {};\r\n    var lastFrameTime = 0;\r\n\r\n    if (typeof requestAnimationFrame === 'function' && typeof cancelAnimationFrame === 'function') {\r\n      frame = function (cb) {\r\n        var id = Math.random();\r\n\r\n        frames[id] = requestAnimationFrame(function onFrame(time) {\r\n          if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {\r\n            lastFrameTime = time;\r\n            delete frames[id];\r\n\r\n            cb();\r\n          } else {\r\n            frames[id] = requestAnimationFrame(onFrame);\r\n          }\r\n        });\r\n\r\n        return id;\r\n      };\r\n      cancel = function (id) {\r\n        if (frames[id]) {\r\n          cancelAnimationFrame(frames[id]);\r\n        }\r\n      };\r\n    } else {\r\n      frame = function (cb) {\r\n        return setTimeout(cb, TIME);\r\n      };\r\n      cancel = function (timer) {\r\n        return clearTimeout(timer);\r\n      };\r\n    }\r\n\r\n    return { frame: frame, cancel: cancel };\r\n  }());\r\n\r\n  var getWorker = (function () {\r\n    var worker;\r\n    var prom;\r\n    var resolves = {};\r\n\r\n    function decorate(worker) {\r\n      function execute(options, callback) {\r\n        worker.postMessage({ options: options || {}, callback: callback });\r\n      }\r\n      worker.init = function initWorker(canvas) {\r\n        var offscreen = canvas.transferControlToOffscreen();\r\n        worker.postMessage({ canvas: offscreen }, [offscreen]);\r\n      };\r\n\r\n      worker.fire = function fireWorker(options, size, done) {\r\n        if (prom) {\r\n          execute(options, null);\r\n          return prom;\r\n        }\r\n\r\n        var id = Math.random().toString(36).slice(2);\r\n\r\n        prom = promise(function (resolve) {\r\n          function workerDone(msg) {\r\n            if (msg.data.callback !== id) {\r\n              return;\r\n            }\r\n\r\n            delete resolves[id];\r\n            worker.removeEventListener('message', workerDone);\r\n\r\n            prom = null;\r\n\r\n            bitmapMapper.clear();\r\n\r\n            done();\r\n            resolve();\r\n          }\r\n\r\n          worker.addEventListener('message', workerDone);\r\n          execute(options, id);\r\n\r\n          resolves[id] = workerDone.bind(null, { data: { callback: id }});\r\n        });\r\n\r\n        return prom;\r\n      };\r\n\r\n      worker.reset = function resetWorker() {\r\n        worker.postMessage({ reset: true });\r\n\r\n        for (var id in resolves) {\r\n          resolves[id]();\r\n          delete resolves[id];\r\n        }\r\n      };\r\n    }\r\n\r\n    return function () {\r\n      if (worker) {\r\n        return worker;\r\n      }\r\n\r\n      if (!isWorker && canUseWorker) {\r\n        var code = [\r\n          'var CONFETTI, SIZE = {}, module = {};',\r\n          '(' + main.toString() + ')(this, module, true, SIZE);',\r\n          'onmessage = function(msg) {',\r\n          '  if (msg.data.options) {',\r\n          '    CONFETTI(msg.data.options).then(function () {',\r\n          '      if (msg.data.callback) {',\r\n          '        postMessage({ callback: msg.data.callback });',\r\n          '      }',\r\n          '    });',\r\n          '  } else if (msg.data.reset) {',\r\n          '    CONFETTI && CONFETTI.reset();',\r\n          '  } else if (msg.data.resize) {',\r\n          '    SIZE.width = msg.data.resize.width;',\r\n          '    SIZE.height = msg.data.resize.height;',\r\n          '  } else if (msg.data.canvas) {',\r\n          '    SIZE.width = msg.data.canvas.width;',\r\n          '    SIZE.height = msg.data.canvas.height;',\r\n          '    CONFETTI = module.exports.create(msg.data.canvas);',\r\n          '  }',\r\n          '}',\r\n        ].join('\\n');\r\n        try {\r\n          worker = new Worker(URL.createObjectURL(new Blob([code])));\r\n        } catch (e) {\r\n          // eslint-disable-next-line no-console\r\n          typeof console !== undefined && typeof console.warn === 'function' ? console.warn('🎊 Could not load worker', e) : null;\r\n\r\n          return null;\r\n        }\r\n\r\n        decorate(worker);\r\n      }\r\n\r\n      return worker;\r\n    };\r\n  })();\r\n\r\n  var defaults = {\r\n    particleCount: 50,\r\n    angle: 90,\r\n    spread: 45,\r\n    startVelocity: 45,\r\n    decay: 0.9,\r\n    gravity: 1,\r\n    drift: 0,\r\n    ticks: 200,\r\n    x: 0.5,\r\n    y: 0.5,\r\n    shapes: ['square', 'circle'],\r\n    zIndex: 100,\r\n    colors: [\r\n      '#26ccff',\r\n      '#a25afd',\r\n      '#ff5e7e',\r\n      '#88ff5a',\r\n      '#fcff42',\r\n      '#ffa62d',\r\n      '#ff36ff'\r\n    ],\r\n    // probably should be true, but back-compat\r\n    disableForReducedMotion: false,\r\n    scalar: 1\r\n  };\r\n\r\n  function convert(val, transform) {\r\n    return transform ? transform(val) : val;\r\n  }\r\n\r\n  function isOk(val) {\r\n    return !(val === null || val === undefined);\r\n  }\r\n\r\n  function prop(options, name, transform) {\r\n    return convert(\r\n      options && isOk(options[name]) ? options[name] : defaults[name],\r\n      transform\r\n    );\r\n  }\r\n\r\n  function onlyPositiveInt(number){\r\n    return number < 0 ? 0 : Math.floor(number);\r\n  }\r\n\r\n  function randomInt(min, max) {\r\n    // [min, max)\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  }\r\n\r\n  function toDecimal(str) {\r\n    return parseInt(str, 16);\r\n  }\r\n\r\n  function colorsToRgb(colors) {\r\n    return colors.map(hexToRgb);\r\n  }\r\n\r\n  function hexToRgb(str) {\r\n    var val = String(str).replace(/[^0-9a-f]/gi, '');\r\n\r\n    if (val.length < 6) {\r\n        val = val[0]+val[0]+val[1]+val[1]+val[2]+val[2];\r\n    }\r\n\r\n    return {\r\n      r: toDecimal(val.substring(0,2)),\r\n      g: toDecimal(val.substring(2,4)),\r\n      b: toDecimal(val.substring(4,6))\r\n    };\r\n  }\r\n\r\n  function getOrigin(options) {\r\n    var origin = prop(options, 'origin', Object);\r\n    origin.x = prop(origin, 'x', Number);\r\n    origin.y = prop(origin, 'y', Number);\r\n\r\n    return origin;\r\n  }\r\n\r\n  function setCanvasWindowSize(canvas) {\r\n    canvas.width = document.documentElement.clientWidth;\r\n    canvas.height = document.documentElement.clientHeight;\r\n  }\r\n\r\n  function setCanvasRectSize(canvas) {\r\n    var rect = canvas.getBoundingClientRect();\r\n    canvas.width = rect.width;\r\n    canvas.height = rect.height;\r\n  }\r\n\r\n  function getCanvas(zIndex) {\r\n    var canvas = document.createElement('canvas');\r\n\r\n    canvas.style.position = 'fixed';\r\n    canvas.style.top = '0px';\r\n    canvas.style.left = '0px';\r\n    canvas.style.pointerEvents = 'none';\r\n    canvas.style.zIndex = zIndex;\r\n\r\n    return canvas;\r\n  }\r\n\r\n  function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\r\n    context.save();\r\n    context.translate(x, y);\r\n    context.rotate(rotation);\r\n    context.scale(radiusX, radiusY);\r\n    context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\r\n    context.restore();\r\n  }\r\n\r\n  function randomPhysics(opts) {\r\n    var radAngle = opts.angle * (Math.PI / 180);\r\n    var radSpread = opts.spread * (Math.PI / 180);\r\n\r\n    return {\r\n      x: opts.x,\r\n      y: opts.y,\r\n      wobble: Math.random() * 10,\r\n      wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),\r\n      velocity: (opts.startVelocity * 0.5) + (Math.random() * opts.startVelocity),\r\n      angle2D: -radAngle + ((0.5 * radSpread) - (Math.random() * radSpread)),\r\n      tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,\r\n      color: opts.color,\r\n      shape: opts.shape,\r\n      tick: 0,\r\n      totalTicks: opts.ticks,\r\n      decay: opts.decay,\r\n      drift: opts.drift,\r\n      random: Math.random() + 2,\r\n      tiltSin: 0,\r\n      tiltCos: 0,\r\n      wobbleX: 0,\r\n      wobbleY: 0,\r\n      gravity: opts.gravity * 3,\r\n      ovalScalar: 0.6,\r\n      scalar: opts.scalar,\r\n      flat: opts.flat\r\n    };\r\n  }\r\n\r\n  function updateFetti(context, fetti) {\r\n    fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;\r\n    fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;\r\n    fetti.velocity *= fetti.decay;\r\n\r\n    if (fetti.flat) {\r\n      fetti.wobble = 0;\r\n      fetti.wobbleX = fetti.x + (10 * fetti.scalar);\r\n      fetti.wobbleY = fetti.y + (10 * fetti.scalar);\r\n\r\n      fetti.tiltSin = 0;\r\n      fetti.tiltCos = 0;\r\n      fetti.random = 1;\r\n    } else {\r\n      fetti.wobble += fetti.wobbleSpeed;\r\n      fetti.wobbleX = fetti.x + ((10 * fetti.scalar) * Math.cos(fetti.wobble));\r\n      fetti.wobbleY = fetti.y + ((10 * fetti.scalar) * Math.sin(fetti.wobble));\r\n\r\n      fetti.tiltAngle += 0.1;\r\n      fetti.tiltSin = Math.sin(fetti.tiltAngle);\r\n      fetti.tiltCos = Math.cos(fetti.tiltAngle);\r\n      fetti.random = Math.random() + 2;\r\n    }\r\n\r\n    var progress = (fetti.tick++) / fetti.totalTicks;\r\n\r\n    var x1 = fetti.x + (fetti.random * fetti.tiltCos);\r\n    var y1 = fetti.y + (fetti.random * fetti.tiltSin);\r\n    var x2 = fetti.wobbleX + (fetti.random * fetti.tiltCos);\r\n    var y2 = fetti.wobbleY + (fetti.random * fetti.tiltSin);\r\n\r\n    context.fillStyle = 'rgba(' + fetti.color.r + ', ' + fetti.color.g + ', ' + fetti.color.b + ', ' + (1 - progress) + ')';\r\n\r\n    context.beginPath();\r\n\r\n    if (canUsePaths && fetti.shape.type === 'path' && typeof fetti.shape.path === 'string' && Array.isArray(fetti.shape.matrix)) {\r\n      context.fill(transformPath2D(\r\n        fetti.shape.path,\r\n        fetti.shape.matrix,\r\n        fetti.x,\r\n        fetti.y,\r\n        Math.abs(x2 - x1) * 0.1,\r\n        Math.abs(y2 - y1) * 0.1,\r\n        Math.PI / 10 * fetti.wobble\r\n      ));\r\n    } else if (fetti.shape.type === 'bitmap') {\r\n      var rotation = Math.PI / 10 * fetti.wobble;\r\n      var scaleX = Math.abs(x2 - x1) * 0.1;\r\n      var scaleY = Math.abs(y2 - y1) * 0.1;\r\n      var width = fetti.shape.bitmap.width * fetti.scalar;\r\n      var height = fetti.shape.bitmap.height * fetti.scalar;\r\n\r\n      var matrix = new DOMMatrix([\r\n        Math.cos(rotation) * scaleX,\r\n        Math.sin(rotation) * scaleX,\r\n        -Math.sin(rotation) * scaleY,\r\n        Math.cos(rotation) * scaleY,\r\n        fetti.x,\r\n        fetti.y\r\n      ]);\r\n\r\n      // apply the transform matrix from the confetti shape\r\n      matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));\r\n\r\n      var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), 'no-repeat');\r\n      pattern.setTransform(matrix);\r\n\r\n      context.globalAlpha = (1 - progress);\r\n      context.fillStyle = pattern;\r\n      context.fillRect(\r\n        fetti.x - (width / 2),\r\n        fetti.y - (height / 2),\r\n        width,\r\n        height\r\n      );\r\n      context.globalAlpha = 1;\r\n    } else if (fetti.shape === 'circle') {\r\n      context.ellipse ?\r\n        context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) :\r\n        ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);\r\n    } else if (fetti.shape === 'star') {\r\n      var rot = Math.PI / 2 * 3;\r\n      var innerRadius = 4 * fetti.scalar;\r\n      var outerRadius = 8 * fetti.scalar;\r\n      var x = fetti.x;\r\n      var y = fetti.y;\r\n      var spikes = 5;\r\n      var step = Math.PI / spikes;\r\n\r\n      while (spikes--) {\r\n        x = fetti.x + Math.cos(rot) * outerRadius;\r\n        y = fetti.y + Math.sin(rot) * outerRadius;\r\n        context.lineTo(x, y);\r\n        rot += step;\r\n\r\n        x = fetti.x + Math.cos(rot) * innerRadius;\r\n        y = fetti.y + Math.sin(rot) * innerRadius;\r\n        context.lineTo(x, y);\r\n        rot += step;\r\n      }\r\n    } else {\r\n      context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));\r\n      context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));\r\n      context.lineTo(Math.floor(x2), Math.floor(y2));\r\n      context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));\r\n    }\r\n\r\n    context.closePath();\r\n    context.fill();\r\n\r\n    return fetti.tick < fetti.totalTicks;\r\n  }\r\n\r\n  function animate(canvas, fettis, resizer, size, done) {\r\n    var animatingFettis = fettis.slice();\r\n    var context = canvas.getContext('2d');\r\n    var animationFrame;\r\n    var destroy;\r\n\r\n    var prom = promise(function (resolve) {\r\n      function onDone() {\r\n        animationFrame = destroy = null;\r\n\r\n        context.clearRect(0, 0, size.width, size.height);\r\n        bitmapMapper.clear();\r\n\r\n        done();\r\n        resolve();\r\n      }\r\n\r\n      function update() {\r\n        if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {\r\n          size.width = canvas.width = workerSize.width;\r\n          size.height = canvas.height = workerSize.height;\r\n        }\r\n\r\n        if (!size.width && !size.height) {\r\n          resizer(canvas);\r\n          size.width = canvas.width;\r\n          size.height = canvas.height;\r\n        }\r\n\r\n        context.clearRect(0, 0, size.width, size.height);\r\n\r\n        animatingFettis = animatingFettis.filter(function (fetti) {\r\n          return updateFetti(context, fetti);\r\n        });\r\n\r\n        if (animatingFettis.length) {\r\n          animationFrame = raf.frame(update);\r\n        } else {\r\n          onDone();\r\n        }\r\n      }\r\n\r\n      animationFrame = raf.frame(update);\r\n      destroy = onDone;\r\n    });\r\n\r\n    return {\r\n      addFettis: function (fettis) {\r\n        animatingFettis = animatingFettis.concat(fettis);\r\n\r\n        return prom;\r\n      },\r\n      canvas: canvas,\r\n      promise: prom,\r\n      reset: function () {\r\n        if (animationFrame) {\r\n          raf.cancel(animationFrame);\r\n        }\r\n\r\n        if (destroy) {\r\n          destroy();\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  function confettiCannon(canvas, globalOpts) {\r\n    var isLibCanvas = !canvas;\r\n    var allowResize = !!prop(globalOpts || {}, 'resize');\r\n    var hasResizeEventRegistered = false;\r\n    var globalDisableForReducedMotion = prop(globalOpts, 'disableForReducedMotion', Boolean);\r\n    var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, 'useWorker');\r\n    var worker = shouldUseWorker ? getWorker() : null;\r\n    var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;\r\n    var initialized = (canvas && worker) ? !!canvas.__confetti_initialized : false;\r\n    var preferLessMotion = typeof matchMedia === 'function' && matchMedia('(prefers-reduced-motion)').matches;\r\n    var animationObj;\r\n\r\n    function fireLocal(options, size, done) {\r\n      var particleCount = prop(options, 'particleCount', onlyPositiveInt);\r\n      var angle = prop(options, 'angle', Number);\r\n      var spread = prop(options, 'spread', Number);\r\n      var startVelocity = prop(options, 'startVelocity', Number);\r\n      var decay = prop(options, 'decay', Number);\r\n      var gravity = prop(options, 'gravity', Number);\r\n      var drift = prop(options, 'drift', Number);\r\n      var colors = prop(options, 'colors', colorsToRgb);\r\n      var ticks = prop(options, 'ticks', Number);\r\n      var shapes = prop(options, 'shapes');\r\n      var scalar = prop(options, 'scalar');\r\n      var flat = !!prop(options, 'flat');\r\n      var origin = getOrigin(options);\r\n\r\n      var temp = particleCount;\r\n      var fettis = [];\r\n\r\n      var startX = canvas.width * origin.x;\r\n      var startY = canvas.height * origin.y;\r\n\r\n      while (temp--) {\r\n        fettis.push(\r\n          randomPhysics({\r\n            x: startX,\r\n            y: startY,\r\n            angle: angle,\r\n            spread: spread,\r\n            startVelocity: startVelocity,\r\n            color: colors[temp % colors.length],\r\n            shape: shapes[randomInt(0, shapes.length)],\r\n            ticks: ticks,\r\n            decay: decay,\r\n            gravity: gravity,\r\n            drift: drift,\r\n            scalar: scalar,\r\n            flat: flat\r\n          })\r\n        );\r\n      }\r\n\r\n      // if we have a previous canvas already animating,\r\n      // add to it\r\n      if (animationObj) {\r\n        return animationObj.addFettis(fettis);\r\n      }\r\n\r\n      animationObj = animate(canvas, fettis, resizer, size , done);\r\n\r\n      return animationObj.promise;\r\n    }\r\n\r\n    function fire(options) {\r\n      var disableForReducedMotion = globalDisableForReducedMotion || prop(options, 'disableForReducedMotion', Boolean);\r\n      var zIndex = prop(options, 'zIndex', Number);\r\n\r\n      if (disableForReducedMotion && preferLessMotion) {\r\n        return promise(function (resolve) {\r\n          resolve();\r\n        });\r\n      }\r\n\r\n      if (isLibCanvas && animationObj) {\r\n        // use existing canvas from in-progress animation\r\n        canvas = animationObj.canvas;\r\n      } else if (isLibCanvas && !canvas) {\r\n        // create and initialize a new canvas\r\n        canvas = getCanvas(zIndex);\r\n        document.body.appendChild(canvas);\r\n      }\r\n\r\n      if (allowResize && !initialized) {\r\n        // initialize the size of a user-supplied canvas\r\n        resizer(canvas);\r\n      }\r\n\r\n      var size = {\r\n        width: canvas.width,\r\n        height: canvas.height\r\n      };\r\n\r\n      if (worker && !initialized) {\r\n        worker.init(canvas);\r\n      }\r\n\r\n      initialized = true;\r\n\r\n      if (worker) {\r\n        canvas.__confetti_initialized = true;\r\n      }\r\n\r\n      function onResize() {\r\n        if (worker) {\r\n          // TODO this really shouldn't be immediate, because it is expensive\r\n          var obj = {\r\n            getBoundingClientRect: function () {\r\n              if (!isLibCanvas) {\r\n                return canvas.getBoundingClientRect();\r\n              }\r\n            }\r\n          };\r\n\r\n          resizer(obj);\r\n\r\n          worker.postMessage({\r\n            resize: {\r\n              width: obj.width,\r\n              height: obj.height\r\n            }\r\n          });\r\n          return;\r\n        }\r\n\r\n        // don't actually query the size here, since this\r\n        // can execute frequently and rapidly\r\n        size.width = size.height = null;\r\n      }\r\n\r\n      function done() {\r\n        animationObj = null;\r\n\r\n        if (allowResize) {\r\n          hasResizeEventRegistered = false;\r\n          global.removeEventListener('resize', onResize);\r\n        }\r\n\r\n        if (isLibCanvas && canvas) {\r\n          document.body.removeChild(canvas);\r\n          canvas = null;\r\n          initialized = false;\r\n        }\r\n      }\r\n\r\n      if (allowResize && !hasResizeEventRegistered) {\r\n        hasResizeEventRegistered = true;\r\n        global.addEventListener('resize', onResize, false);\r\n      }\r\n\r\n      if (worker) {\r\n        return worker.fire(options, size, done);\r\n      }\r\n\r\n      return fireLocal(options, size, done);\r\n    }\r\n\r\n    fire.reset = function () {\r\n      if (worker) {\r\n        worker.reset();\r\n      }\r\n\r\n      if (animationObj) {\r\n        animationObj.reset();\r\n      }\r\n    };\r\n\r\n    return fire;\r\n  }\r\n\r\n  // Make default export lazy to defer worker creation until called.\r\n  var defaultFire;\r\n  function getDefaultFire() {\r\n    if (!defaultFire) {\r\n      defaultFire = confettiCannon(null, { useWorker: true, resize: true });\r\n    }\r\n    return defaultFire;\r\n  }\r\n\r\n  function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {\r\n    var path2d = new Path2D(pathString);\r\n\r\n    var t1 = new Path2D();\r\n    t1.addPath(path2d, new DOMMatrix(pathMatrix));\r\n\r\n    var t2 = new Path2D();\r\n    // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix\r\n    t2.addPath(t1, new DOMMatrix([\r\n      Math.cos(rotation) * scaleX,\r\n      Math.sin(rotation) * scaleX,\r\n      -Math.sin(rotation) * scaleY,\r\n      Math.cos(rotation) * scaleY,\r\n      x,\r\n      y\r\n    ]));\r\n\r\n    return t2;\r\n  }\r\n\r\n  function shapeFromPath(pathData) {\r\n    if (!canUsePaths) {\r\n      throw new Error('path confetti are not supported in this browser');\r\n    }\r\n\r\n    var path, matrix;\r\n\r\n    if (typeof pathData === 'string') {\r\n      path = pathData;\r\n    } else {\r\n      path = pathData.path;\r\n      matrix = pathData.matrix;\r\n    }\r\n\r\n    var path2d = new Path2D(path);\r\n    var tempCanvas = document.createElement('canvas');\r\n    var tempCtx = tempCanvas.getContext('2d');\r\n\r\n    if (!matrix) {\r\n      // attempt to figure out the width of the path, up to 1000x1000\r\n      var maxSize = 1000;\r\n      var minX = maxSize;\r\n      var minY = maxSize;\r\n      var maxX = 0;\r\n      var maxY = 0;\r\n      var width, height;\r\n\r\n      // do some line skipping... this is faster than checking\r\n      // every pixel and will be mostly still correct\r\n      for (var x = 0; x < maxSize; x += 2) {\r\n        for (var y = 0; y < maxSize; y += 2) {\r\n          if (tempCtx.isPointInPath(path2d, x, y, 'nonzero')) {\r\n            minX = Math.min(minX, x);\r\n            minY = Math.min(minY, y);\r\n            maxX = Math.max(maxX, x);\r\n            maxY = Math.max(maxY, y);\r\n          }\r\n        }\r\n      }\r\n\r\n      width = maxX - minX;\r\n      height = maxY - minY;\r\n\r\n      var maxDesiredSize = 10;\r\n      var scale = Math.min(maxDesiredSize/width, maxDesiredSize/height);\r\n\r\n      matrix = [\r\n        scale, 0, 0, scale,\r\n        -Math.round((width/2) + minX) * scale,\r\n        -Math.round((height/2) + minY) * scale\r\n      ];\r\n    }\r\n\r\n    return {\r\n      type: 'path',\r\n      path: path,\r\n      matrix: matrix\r\n    };\r\n  }\r\n\r\n  function shapeFromText(textData) {\r\n    var text,\r\n        scalar = 1,\r\n        color = '#000000',\r\n        // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/\r\n        fontFamily = '\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\", \"EmojiOne Color\", \"Android Emoji\", \"Twemoji Mozilla\", \"system emoji\", sans-serif';\r\n\r\n    if (typeof textData === 'string') {\r\n      text = textData;\r\n    } else {\r\n      text = textData.text;\r\n      scalar = 'scalar' in textData ? textData.scalar : scalar;\r\n      fontFamily = 'fontFamily' in textData ? textData.fontFamily : fontFamily;\r\n      color = 'color' in textData ? textData.color : color;\r\n    }\r\n\r\n    // all other confetti are 10 pixels,\r\n    // so this pixel size is the de-facto 100% scale confetti\r\n    var fontSize = 10 * scalar;\r\n    var font = '' + fontSize + 'px ' + fontFamily;\r\n\r\n    var canvas = new OffscreenCanvas(fontSize, fontSize);\r\n    var ctx = canvas.getContext('2d');\r\n\r\n    ctx.font = font;\r\n    var size = ctx.measureText(text);\r\n    var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);\r\n    var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);\r\n\r\n    var padding = 2;\r\n    var x = size.actualBoundingBoxLeft + padding;\r\n    var y = size.actualBoundingBoxAscent + padding;\r\n    width += padding + padding;\r\n    height += padding + padding;\r\n\r\n    canvas = new OffscreenCanvas(width, height);\r\n    ctx = canvas.getContext('2d');\r\n    ctx.font = font;\r\n    ctx.fillStyle = color;\r\n\r\n    ctx.fillText(text, x, y);\r\n\r\n    var scale = 1 / scalar;\r\n\r\n    return {\r\n      type: 'bitmap',\r\n      // TODO these probably need to be transfered for workers\r\n      bitmap: canvas.transferToImageBitmap(),\r\n      matrix: [scale, 0, 0, scale, -width * scale / 2, -height * scale / 2]\r\n    };\r\n  }\r\n\r\n  module.exports = function() {\r\n    return getDefaultFire().apply(this, arguments);\r\n  };\r\n  module.exports.reset = function() {\r\n    getDefaultFire().reset();\r\n  };\r\n  module.exports.create = confettiCannon;\r\n  module.exports.shapeFromPath = shapeFromPath;\r\n  module.exports.shapeFromText = shapeFromText;\r\n}((function () {\r\n  if (typeof window !== 'undefined') {\r\n    return window;\r\n  }\r\n\r\n  if (typeof self !== 'undefined') {\r\n    return self;\r\n  }\r\n\r\n  return this || {};\r\n})(), module, false));\r\n\r\n// end source content\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);\r\nvar create = module.exports.create;\r\n\n\n//# sourceURL=webpack:///./node_modules/canvas-confetti/dist/confetti.module.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./content_scripts/confetti.js");
/******/ 	
/******/ })()
;